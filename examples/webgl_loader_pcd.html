<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - PCD</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;

			}

			a { color: #d14826 }
			.button { background:#999; color:#eee; padding:0.2em 0.5em; cursor:pointer }
			.highlight { background:orange; color:#fff; }

			span {
				display: inline-block;
				width: 60px;
				text-align: center;
			}

		</style>
	</head>
	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a>
			<a href="http://pointclouds.org/documentation/tutorials/pcd_file_format.php#pcd-file-format" target="_blank" rel="noopener">PCD File format</a>
			<div>PCD loader test by <a href="http://filipecaixeta.com.br" target="_blank" rel="noopener">Filipe Caixeta</a></div>
			<div>+/-: Increase/Decrease point size</div>
			<div>c: Toggle color</div>
		</div>


		<script src="../build/three.js"></script>
		<script src="../src/loaders/FileLoader.js"></script>
		<script src="js/controls/TrackballControls.js"></script>
		<script src="js/WebGL.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.js"></script>

		<script>

			if ( WEBGL.isWebGLAvailable() === false ) {

				document.body.appendChild( WEBGL.getWebGLErrorMessage() );

			}

			var container, stats;
			var mainCamera, controls, scene, renderer;

			var devicePosition = {
				x: -327.98520708801834,
				y: 204.22425485218272,
                z: -20.098459879167386
            }

            var deviceHeading = [
                -0.018115165464278396,
                -0.009781531386689035,
				-0.981582379479962,
                -0.1899268141110922
            ]

			let headingFrontLeft = {
				q: [
					-0.4178493949367778,
					-0.5633034056097154,
					0.5814999642685118,
					0.4122486481908517
				],
				c: 0xfffff0,
				position: {
					y: 204.34262455950343,
					x: -328.2917872842141,
					z: -19.24435161802045
				},
				fx: 561.997914,
				cy: 361.97667,
				cx: 664.16411,
				fy: 561.585651,
                type: 'headingFrontLeft'
			};
			let headingFrontRight = {
				q: [
					-0.6941616713091042,
					-0.16814164434593812,
					0.17574426389318645,
					0.6774820405225789
				],
				c: 0xffff00,
				position: {
					y: 204.41895776958367,
					x: -328.3390016244738,
					z: -19.248419906797995
				},
				fx: 537.74122,
				cy: 353.596887,
				cx: 687.798477,
				fy: 541.411032,
                type: 'headingFrontRight'
			};
			let teleopFront = {
				q: [
					0.6881374107348317,
					0.4572168969720992,
					-0.32417672681053933,
					-0.46079177820873785
				],
				c: 0xFF00FF,
				position: {
					y: 204.38744136624135,
					x: -328.3470888329832,
					z: -19.41486708853337
				},
				fx: 153.798886,
				cy: 394.208215,
				cx: 677.327617,
				fy: 154.020918,
                type: 'teleopFront'
			};
			let teleopLeft = {
				q: [
					0.08928241099814646,
					0.8548764539379589,
					-0.5085064572487883,
					-0.051342794286097934
				],
				c: 0x0000ff,
				position: {
					y: 204.13167508850702,
					x: -328.33242614335956,
					z: -19.241266801048017
				},
				fx: 326.176108,
				cy: 338.922572,
				cx: 258.66729,
				fy: 326.603731,
                type: 'teleopLeft'
			};
			let teleopRight = {
				q: [
					-0.8391294901374513,
					0.2362714087555639,
					-0.13908397136239076,
					0.46977991559493926
				],
				c: 0x00F0ff,
				position: {
					y: 204.56744910213462,
					x: -328.15011943689217,
					z: -19.25282305638503
				},
				fx: 315.153628,
				cy: 350.786817,
				cx: 470.966126,
				fy: 315.099825,
                type: 'teleopRight'
			};
			let teleopRear = {
				q: [
					-0.5212033391413391,
					0.7619994771462804,
					-0.3249699771731485,
					0.2051789219993048
				],
				c: 0x00ff00,
				position: {
					y: 204.10687433390964,
					x: -327.6329399355151,
					z: -19.241833147599746
				},
				fx: 354.848025,
				cy: 331.448458,
				cx: 812.600868,
				fy: 356.521296,
                type: 'teleopRear'
			};

			init();
			animate();

			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				scene.add(new THREE.AxesHelper(5))

				mainCamera = new THREE.PerspectiveCamera( 15, 1280/720 , 0.01, 40 );
				mainCamera.position.x = 24.930370491677184
				mainCamera.position.y = -6.674151720211394
				mainCamera.position.z = 15.294846385737351
				mainCamera.up.set( 0, 0, 1 );

				controls = new THREE.TrackballControls( mainCamera );

				controls.rotateSpeed = 2.0;
				controls.zoomSpeed = 0.3;
				controls.panSpeed = 0.2;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.minDistance = 0.3;
				controls.maxDistance = 0.3 * 100;

				scene.add( mainCamera );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				axios
					.get('https://playment-uploads.s3.amazonaws.com/Marble/2018/11/16/5be3d3d8d1f6670069791d96/0.bin', {
						responseType: 'arraybuffer'
					})
					.then(response => {
						let arrayBuffer = response.data
						let data = new Float32Array(arrayBuffer)
						let vertices = []
						for (let i = 0; i < data.length; i += 4) {
							let dataArray = [data[i], data[i + 1], data[i + 2]]
							const star = new THREE.Vector3()
							star.x = dataArray[0]
							star.y = dataArray[1]
							star.z = dataArray[2]
							vertices.push(star)
						}
						let geometry = new THREE.Geometry()
						geometry.verticesNeedUpdate = true
						geometry.vertices = vertices
						const upperPlaneCloudMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.08})
						const world = new THREE.Points( geometry, upperPlaneCloudMaterial)
                        scene.add(world)

                        // Add device helper
                        addDeviceArrowHelpers([{q: deviceHeading, c: 0xff0000}])

                        // Add Camera helpers
						addCameraArrowHelpers([headingFrontLeft, headingFrontRight, teleopFront, teleopLeft, teleopRight, teleopRear])

						// addProjectionCamera(teleopFront)
                        // addProjectionCamera(teleopRear)
						// addProjectionCamera(teleopLeft)
						// addProjectionCamera(teleopRight)
                        //
						// addProjectionCamera(headingFrontLeft)
						addProjectionCamera(headingFrontRight)
					})

				// loader.load( './models/pcd/binary/Zaghetto.pcd', function ( mesh ) {
				//
				// 	scene.add( mesh );
				// 	var center = mesh.geometry.boundingSphere.center;
				// 	controls.target.set( center.x, center.y, center.z );
				// 	controls.update();
				//
				// } );

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

				window.addEventListener( 'keypress', keyboard );

			}

			function addDeviceArrowHelpers(helpers) {
				helpers.forEach(helper => {
					let dir = new THREE.Vector3( 1, 0, 0);
					let heading = new THREE.Quaternion(helper.q[0], helper.q[1], helper.q[2], helper.q[3])
					dir.applyQuaternion( heading )
					let origin = new THREE.Vector3( 0, 0, 0 );
					let length = 3;
					let hex = helper.c;
					let arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ,0.5,0.2);
					scene.add(arrowHelper)
                    this.device = dir
                })

			}

			function addCameraArrowHelpers(helpers) {
				helpers.forEach(helper => {
					let dir = new THREE.Vector3( 0, 0, 1);
					let heading = new THREE.Quaternion(helper.q[0], helper.q[1], helper.q[2], helper.q[3])
					dir.applyQuaternion( heading )
					let origin = new THREE.Vector3( helper.position.x - devicePosition.x,
                        helper.position.y - devicePosition.y,
                        helper.position.z - devicePosition.z );
					// let origin = new THREE.Vector3( 0,0,0);
					let length = 3;
					let hex = helper.c;
					this[helper.type] = dir
					let arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex ,0.5,0.2);
					scene.add(arrowHelper)
				})

			}

			function addProjectionCamera(projectionCamera) {
                // let quaternion = new THREE.Quaternion(
                // 	projectionCamera.q[0],
                //     projectionCamera.q[1],
                //     projectionCamera.q[2],
                //     projectionCamera.q[3])
                //
                // let lidarQuaternion = new THREE.Quaternion(deviceHeading[0], deviceHeading[1], deviceHeading[2], deviceHeading[3])

                let rotationQuaternion = new THREE.Quaternion().setFromUnitVectors(this.device.normalize(), this[projectionCamera.type].normalize())

                let rotationTranslationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(rotationQuaternion)
                let translation = {
					x: projectionCamera.position.x - devicePosition.x,
					y: projectionCamera.position.y - devicePosition.y,
					z: projectionCamera.position.z - devicePosition.z
                }
                rotationTranslationMatrix.elements[3] = translation.x
				rotationTranslationMatrix.elements[7] = translation.y
				rotationTranslationMatrix.elements[11] = translation.z


				let fx = projectionCamera.fx
				let cy = projectionCamera.cy
				let cx = projectionCamera.cx
				let fy = projectionCamera.fy

                let cameraMatrix = new THREE.Matrix4()
				cameraMatrix.set(
                    fx,0,-cx,0,
                    0,fy,-cy,0,
                    0,0,-1,0,
                    0,0,-1,0
                )
                let projectionMatrix = cameraMatrix.multiply(rotationTranslationMatrix)

				var camera = new THREE.PerspectiveCamera(
					Math.atan(1/projectionMatrix.elements[10])*2 * 180/Math.PI,
					window.innerWidth/window.innerHeight, 0.1, 1000)

                camera.position.x = projectionCamera.position.x - devicePosition.x
                camera.position.y = projectionCamera.position.y - devicePosition.y
				camera.position.z = projectionCamera.position.z - devicePosition.z




                let cameraquaternion = new THREE.Quaternion(
                	projectionCamera.q[0],
                    projectionCamera.q[1],
                    projectionCamera.q[2],
                    projectionCamera.q[3])
                camera.rotation.setFromQuaternion(cameraquaternion)
				camera.rotation.y += Math.PI


				// camera.projectionMatrix.set(
				// 	projectionMatrix.elements[0],
				// 	projectionMatrix.elements[1],
				// 	projectionMatrix.elements[2],
				// 	projectionMatrix.elements[3],
				// 	projectionMatrix.elements[4],
				// 	projectionMatrix.elements[5],
				// 	projectionMatrix.elements[6],
				// 	projectionMatrix.elements[7],
				// 	projectionMatrix.elements[8],
				// 	projectionMatrix.elements[9],
				// 	projectionMatrix.elements[10],
				// 	projectionMatrix.elements[11],
				// 	projectionMatrix.elements[12],
				// 	projectionMatrix.elements[13],
				// 	projectionMatrix.elements[14],
				// 	projectionMatrix.elements[15],
				// )

                this.testCamera = camera
				var helper = new THREE.CameraHelper( camera );



				// Frustum helper
				// let frustum = new THREE.Frustum()
				// frustum.setFromMatrix(rotationTranslationMatrix)
				// let planes = frustum.planes
                //
                //
				// var helper0 = new THREE.PlaneHelper( planes[0], 1, 0xffff00 )
				// var helper1 = new THREE.PlaneHelper( planes[1], 1, 0xffff00 )
				// var helper2 = new THREE.PlaneHelper( planes[2], 1, 0xffff00 )
				// var helper3 = new THREE.PlaneHelper( planes[3], 1, 0xffff00 )
				// var helper4 = new THREE.PlaneHelper( planes[4], 1, 0xffff00 )
				// var helper5 = new THREE.PlaneHelper( planes[5], 1, 0xffff00 )
                //
				// let helperContainer = new THREE.Group()
				// helperContainer.add(helper0,
				// 	helper1,
				// 	helper2,
				// 	helper3,
				// 	helper4,
				// 	helper5)
				// helperContainer.position.x = translation.x
				// helperContainer.position.y = translation.y
				// helperContainer.position.y = translation.z
				// scene.add(helperContainer)

				// end Frustum helper

                scene.add(camera, helper)
			}

			function onWindowResize() {

				mainCamera.aspect = window.innerWidth / window.innerHeight;
				mainCamera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				controls.handleResize();

			}

			function keyboard( ev ) {

				var ZaghettoMesh = scene.getObjectByName( 'Zaghetto.pcd' );

				switch ( ev.key || String.fromCharCode( ev.keyCode || ev.charCode ) ) {

					case '+':
						ZaghettoMesh.material.size *= 1.2;
						ZaghettoMesh.material.needsUpdate = true;
						break;

					case '-':
						ZaghettoMesh.material.size /= 1.2;
						ZaghettoMesh.material.needsUpdate = true;
						break;

					case 'c':
						ZaghettoMesh.material.color.setHex( Math.random() * 0xffffff );
						ZaghettoMesh.material.needsUpdate = true;
						break;

				}

			}

			function animate() {

				requestAnimationFrame( animate );
				controls.update();
				stats.update();
				this.testCamera && renderer.render( scene, this.testCamera );

			}

		</script>
	</body>
</html>
